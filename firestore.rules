
/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model. All user-generated
 * content is private and can only be accessed by the user who created it. There is no
 * public or shared data.
 *
 * Data Structure: All data is hierarchically nested under the `/users/{userId}` collection.
 * This structure inherently links data to its owner, simplifying security rules and
 * ensuring that a user can only operate within their own data tree. For example, a user's
 * goal is stored at `/users/{userId}/sessions/{sessionId}/categoryGoals/{goalId}`.
 *
 * Key Security Decisions:
 * - Default Deny: All access is denied by default. Rules explicitly grant permissions.
 * - User Isolation: Users are strictly isolated. A user can NEVER read, write, or even
 *   see data belonging to another user.
 * - No User Listing: It is forbidden to query the top-level `/users` collection to prevent
 *   user enumeration.
 * - Path-based Security: Authorization is primarily determined by matching the authenticated
 *   user's ID (`request.auth.uid`) with the `{userId}` wildcard in the document path. This
 *   is highly performant as it avoids extra database reads (`get()` calls).
 *
 * Denormalization for Authorization: The hierarchical structure `/users/{userId}/...` serves
 * as a form of structural denormalization. By placing data under a user-specific path,
 * ownership is implicitly defined, eliminating the need to add an `ownerId` field to every
 * single document and then read it for authorization checks.
 *
 * Structural Segregation: The entire data model uses structural segregation. All private
 * user data resides exclusively under the `/users/{userId}` path, ensuring a clear and
 * secure separation between different users' data.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the provided userId.
     * This is the core of the ownership-based security model.
     * @param userId The UID of the document owner.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks if a document exists and if the requester is the owner.
     * Used for safe update and delete operations.
     * @param userId The UID of the document owner.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Validates required relational fields for a UserAccount document on create.
     * In Prototyping Mode, we only validate fields critical for authorization.
     * @param userId The user ID from the path, to ensure path and data match.
     */
    function isValidUserAccountOnCreate(userId) {
      // Enforce that the document's internal ID matches the document path ID.
      return request.resource.data.id == userId;
    }

    /**
     * Validates immutability of critical relational fields for a UserAccount on update.
     */
    function isValidUserAccountOnUpdate() {
      // The user's own ID should never be changed.
      return request.resource.data.id == resource.data.id
          // Allow googleRefreshToken to be added or changed
          && ('googleRefreshToken' in request.resource.data || !('googleRefreshToken' in resource.data));
    }

    /**
     * Validates required relational fields for a Session document on create.
     * @param userId The user ID from the path.
     */
    function isValidSessionOnCreate(userId) {
      // Enforce that the session document correctly references its parent user.
      return request.resource.data.userAccountId == userId;
    }

    /**
     * Validates immutability of critical relational fields for a Session on update.
     */
    function isValidSessionOnUpdate() {
      // The owning user ID must not be changed.
      return request.resource.data.userAccountId == resource.data.userAccountId;
    }

    /**
     * Validates required relational fields for any document nested under a Session.
     * @param sessionId The session ID from the path.
     */
    function isValidSessionChildOnCreate(sessionId) {
      // Enforce that any sub-collection item correctly references its parent session.
      return request.resource.data.sessionID == sessionId;
    }
    
    /**
     * Validates immutability of critical relational fields for a Session child on update.
     */
    function isValidSessionChildOnUpdate() {
        // The parent session ID must not be changed.
        return request.resource.data.sessionID == resource.data.sessionID;
    }

    // ------------------------------------------------------------------------
    // Collection Rules
    // ------------------------------------------------------------------------

    /**
     * @description Controls access to a user's own account document.
     * @path /users/{userId}
     * @allow (create) An authenticated user can create their own account document.
     * @deny  (create) An authenticated user cannot create an account for another user.
     * @deny  (list) No one can list all documents in the `/users` collection.
     * @principle Restricts access to a user's own data tree and allows self-creation of a root user document.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false; // CRITICAL: Prevents user enumeration.
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId) && isValidUserAccountOnUpdate();
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to a user's session documents.
     * @path /users/{userId}/sessions/{sessionId}
     * @allow (create) An authenticated user can create a session for themselves.
     * @deny  (get) An authenticated user cannot read another user's session.
     * @principle Enforces document ownership for all operations within a user's private subcollection.
     */
    match /users/{userId}/sessions/{sessionId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && isValidSessionOnCreate(userId);
      allow update: if isExistingOwner(userId) && isValidSessionOnUpdate();
      allow delete: if isExistingOwner(userId);
    }
    
    /**
     * @description Controls access to a user's cycle tracking data.
     * @path /users/{userId}/cycles/{cycleId}
     * @allow (get, list, create, update, delete) A user can manage their own cycle data.
     */
    match /users/{userId}/cycles/{cycleId} {
        allow read, write: if isOwner(userId);
    }

     /**
     * @description Controls access to notes within a specific cycle day.
     * @path /users/{userId}/cycles/{cycleId}/notes/{noteId}
     * @allow (get, list, create, update, delete) A user can manage notes for their own cycle days.
     */
    match /users/{userId}/cycles/{cycleId}/notes/{noteId} {
        allow read, write: if isOwner(userId);
    }

    /**
     * @description Controls access to all data nested within a specific session. This single rule
     *              applies to successDefinitions, lifeVisionMilestones, actionPlanItems, etc.
     * @path /users/{userId}/sessions/{sessionId}/{collection}/{docId}
     * @allow (create) An authenticated user can create a document inside one of their own sessions.
     * @deny  (update) An authenticated user cannot modify a document in another user's session.
     * @principle Leverages wildcards for scalable security, enforcing ownership and relational
     *              integrity for all deeply nested user content.
     */
    match /users/{userId}/sessions/{sessionId}/{collection}/{docId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && isValidSessionChildOnCreate(sessionId);
      allow update: if isExistingOwner(userId) && isValidSessionChildOnUpdate();
      allow delete: if isExistingOwner(userId);
    }
  }
}
